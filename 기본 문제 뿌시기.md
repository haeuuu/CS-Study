### ğŸƒâ€â™€ Stack, Queue, Heap, DFS/BFS ë“± ê¸°ë³¸ ë¬¸ì œë¥¼ ë‹¤ì‹œ í’€ì–´ë³´ì !
1. **[Stack/Queue](#Stack/Queue)**
2. **[DFS/BFS](#DFS/BFS)**
2. **[Heap](#Heap)**


---
# Stack/Queue
## ë¯¸ë¡œíƒí—˜
```python
import collections

N,M = map(int,input().split())
A = [list(map(int,input())) for _ in range(N)]

def BFS(x,y):
    q = collections.deque([(x,y)])
    while q:
        x,y = q.popleft()
        for a,b in [(x,y-1),(x,y+1),(x-1,y),(x+1,y)]:
            if 0<=a<N and 0<=b<M and A[a][b] == 1:
                A[a][b] += A[x][y]
                q.append((a,b))
    return A[-1][-1]

print(BFS(0,0))
```

# DFS/BFS
## ë¯¸ë¡œ íƒìƒ‰

ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œ => BFS !

ì´ ë•Œ ì§€ë‚˜ê°„ ìë¦¬ëŠ” ì•„ì˜ˆ ìˆ«ìë¥¼ ë°”ê¿”ë²„ë¦¬ì.

popì´ ì•„ë‹ˆë¼ appendí•˜ê¸° ì „ì— ë°”ê¾¸ëŠ” ê²ƒ ìŠì§€ë§ê¸° !

![image-20201221205122140](../../fig/image-20201221205122140.png)

```python
import collections

N,M = map(int,input().split())
A = [list(map(int,input())) for _ in range(N)]

def BFS(x,y):
    q = collections.deque([(x,y)])
    while q:
        x,y = q.popleft()
        for a,b in [(x,y-1),(x,y+1),(x-1,y),(x+1,y)]:
            if 0<=a<N and 0<=b<M and A[a][b] == 1:
                ###################
                A[a][b] += A[x][y]
                ################### ìƒíƒœ ë³€í™”
                q.append((a,b))
    return A[-1][-1]

print(BFS(0,0))
```



## ì˜ì—­ êµ¬í•˜ê¸°

ì§ì‚¬ê°í˜•ì—ê²Œ ë¨¹íˆì§€ ì•Šì€ ì¢…ì´ì˜ ë¶€ë¶„ë¶€ë¶„ ì¤‘ì—ì„œ ê°€ì¥ í° ì˜ì—­ì˜ í¬ê¸°ëŠ” ì–¼ë§ˆ?

ê³„ì‚°í•œ ì¹¸ì´ë¼ëŠ” ì˜ë¯¸ì—ì„œ ê°’ì„ 1ë¡œ ë°”ê¿”ì¤€ë‹¤.

* ì—­ì‹œ initì—ì„œ í•œë²ˆ, appendí•˜ê¸° ì „ì— í•œ ë²ˆ ìƒíƒœ ë³€í™” !

```python
from collections import deque

M,N,K = map(int, input().split())
paper = [[0]*M for _ in range(N)]

for _ in range(K):
    lx,ly,rx,ry = map(int, input().split())
    for i in range(lx,rx):
        for j in range(ly,ry):
            paper[i][j] = 1

def get_size(x,y):
    size = 0
    queue = deque([(x,y)])
    ###############
    paper[x][y] = 1
    ############### ìƒíƒœ ë³€í™”

    while queue:
        x,y = queue.popleft()
        size += 1

        for dx,dy in [(0,1),(1,0),(-1,0),(0,-1)]:
            if x+dx<0 or x+dx>=N or y+dy<0 or y+dy>=M:
                continue
            if paper[x+dx][y+dy] == 0:
                #####################
                paper[x+dx][y+dy] = 1
                ##################### ìƒíƒœ ë³€í™”
                queue.append((x+dx,y+dy))

    return size

sizes = []
for i in range(N):
    for j in range(M):
        if paper[i][j] == 0:
            sizes.append(get_size(i,j))

print(len(sizes))
print(*sorted(sizes))
```



## ì¼€ë¹ˆ ë² ì´ì»¨ì˜ 6ë‹¨ê³„ ë²•ì¹™

```python
from collections import deque

N,M = map(int,input().split())
friends = {i:[] for i in range(N)}
for _ in range(M):
    a,b = map(int,input().split())
    friends[a-1].append(b-1)
    friends[b-1].append(a-1)

def get_kevin_number(name):
    queue = deque([(0,name)])
    kevin_num = [-1]*N
    kevin_num[name] = 0

    while queue:
        depth, name = queue.popleft()
        for friend in friends[name]:
            if kevin_num[friend] < 0:
                #############################
                kevin_num[friend] = depth + 1
                #############################
                queue.append((depth + 1, friend))

    return sum(kevin_num)

ans = []
for name in range(N):
    ans.append((get_kevin_number(name),name))
print(sorted(ans)[0][1] + 1)
```



## :speech_balloon: ë¿Œìš”ë¿Œìš”

1. í„°ëœ¨ë¦´ ë¸”ë¡ì´ ìˆëŠ”ì§€ í™•ì¸í•œë‹¤.
   * í„°ëœ¨ë¦´ ìˆ˜ ìˆë‹¤ë©´ ì¢Œí‘œë¥¼ returní•˜ê²Œ í•œë‹¤.
2. ë§Œì•½ í•˜ë‚˜ë„ ì—†ë‹¤ë©´ ì¤‘ì§€í•œë‹¤.
3. í•˜ë‚˜ë¼ë„ ìˆë‹¤ë©´, ê·¸ ì¢Œí‘œë¥¼ ë°›ì•„ í„°ëœ¨ë¦°ë‹¤.
4. ë¸”ë¡ì„ ë‚´ë¦°ë‹¤.

```python
from collections import deque

class Puyo:
    def __init__(self, arr):
        self.arr = arr

    def catch_bomb(self,x,y):
        color = self.arr[x][y]

        self.visit[x][y] = True

        coordinates = []
        queue = deque([(x,y)])

        while queue:
            x,y = queue.popleft()
            coordinates.append((x,y))
            for dx,dy in [(0,1),(1,0),(-1,0),(0,-1)]:
                if x+dx<0 or x+dx>=12 or y+dy<0 or y+dy>=6:
                    continue
                if self.arr[x+dx][y+dy] == color and not self.visit[x+dx][y+dy]:
                    queue.append((x+dx,y+dy))
                    self.visit[x+dx][y+dy] = True

        return coordinates if len(coordinates) >= 4 else []

    def check(self):
        bomb_coordinates = []
        self.visit = [[False]*6 for _ in range(12)]

        for i in range(12):
            for j in range(6):
                if self.arr[i][j] != '.' and not self.visit[i][j]:
                    coord = self.catch_bomb(i,j)
                    if coord:
                        bomb_coordinates.extend(coord)

        return bomb_coordinates

    def pop(self, bomb_coordinates):
        for x,y in bomb_coordinates:
            self.arr[x][y] = '.'

    def drop(self):
        for j in range(6):
            puyo = [self.arr[i][j] for i in range(12) if self.arr[i][j] != '.']
            dropped_puyo = ['.']*(12-len(puyo)) + puyo
            for i in range(12):
                self.arr[i][j] = dropped_puyo[i]

puyo = Puyo([list(input()) for _ in range(12)])

answer = 0
while True:
    bomb_coordinates = puyo.check()
    if not bomb_coordinates:
        break
    puyo.pop(bomb_coordinates)
    puyo.drop()
    answer += 1

print(answer)
```



## :speech_balloon: â€‹ ë¡œë´‡

> êµ¬êµ¬ì ˆì ˆ í•˜ì§€ë§Œ ë””ë²„ê¹…í•˜ê¸° í¸í•˜ë‹¤ !

```python
from collections import deque

class Robot:
    def __init__(self, n,m,arr, init, goal):
        self.arr = arr
        self.n,self.m = n,m
        self.init_x, self.init_y, self.init_dir = init
        self.goal_x, self.goal_y, self.goal_dir = goal
        self.turn_left = {1:4,4:2,2:3,3:1}
        self.turn_right = {1:3,3:2,2:4,4:1}

    def end_state(self,x,y,dir):
        return (x,y,dir) == (self.goal_x, self.goal_y, self.goal_dir)

    def go(self,x,y,dir,k):

        if dir == 1 or dir == 2:
            view = range(y,y+k+1) if dir == 1 else range(y-k,y)
            for j in view:
                if j < 0 or j >= self.m or self.arr[x][j] == 1:
                    return False, (x,y,dir)
            return True, (x,view[-1 if dir == 1 else 0],dir)
        else:
            view = range(x,x+k+1) if dir == 3 else range(x-k,x)
            for i in view:
                if i < 0 or i >= self.n or self.arr[i][y] == 1:
                    return False, (x,y,dir)
            return True, (view[-1 if dir == 3 else 0],y,dir)

    def turn(self,x,y,dir,where):
        if where == 0: # ì™¼ìª½
            return x,y,self.turn_left[dir]
        else:
            return x,y,self.turn_right[dir]

    def move(self):
        visit = [[[False]*5 for _ in range(m)] for _ in range(n)]
        queue = deque([(self.init_x,self.init_y,self.init_dir,0)])
        visit[self.init_x][self.init_y][self.init_dir] = True

        while queue:
            x,y,dir,depth = queue.popleft()
            if self.end_state(x,y,dir):
                return depth

            for rotate in [0,1]:
                nx,ny,ndir = self.turn(x,y,dir, rotate)
                if not visit[nx][ny][ndir]:
                    visit[nx][ny][ndir] = True
                    queue.append((nx,ny,ndir,depth+1))

            for k in [1,2,3]:
                flag,(nx,ny,ndir) = self.go(x,y,dir,k)
                if flag and not visit[nx][ny][ndir]:
                    visit[nx][ny][ndir] = True
                    queue.append((nx,ny,ndir,depth+1))

import sys
f = lambda :list(map(int,sys.stdin.readline().strip().split()))

n,m = f()
arr = [f() for _ in range(n)]

sx,sy,sdir = f()
ex,ey,edir = f()
robot = Robot(n,m,arr,(sx-1,sy-1,sdir),(ex-1,ey-1,edir))
print(robot.move())
```



## ì•ˆì „ì˜ì—­

```python
import sys
sys.setrecursionlimit(2**30)

N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]

M = max(max(ls) for ls in arr)

def raining(k):
    for i in range(N):
        for j in range(N):
            if arr[i][j] <= k:
                arr[i][j] *= -1

def sunny():
    for i in range(N):
        for j in range(N):
            arr[i][j] *= -1

def DFS(x, y):
    arr[x][y] *= -1
    for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
        if x + dx < 0 or x + dx >= N or y + dy < 0 or y + dy >= N:
            continue
        if arr[x + dx][y + dy] > 0:
            DFS(x + dx, y + dy)

answers = []
for k in range(M + 1):
    raining(k)
    safty = 0
    for i in range(N):
        for j in range(N):
            if arr[i][j] > 0:
                DFS(i, j)
                safty += 1
    answers.append(safty)
    sunny()
print(max(answers))
```



# Heap
## ë” ë§µê²Œ



##### ë°°ì›Œê°ˆ ê²ƒ

* popí•˜ê¸° ì „ì— ì–¸ì œë‚˜ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸ !!!!!!

  íŠ¹íˆ ì´ ë¬¸ì œëŠ” popì„ ë‘ ë²ˆ í•˜ëŠ”ë°, ì²«ë²ˆì§¸ popì´ ì•„ë‹ˆë¼ ë‘ë²ˆì§¸ popì—ì„œ ê±¸ëŸ¬ë‚¸ë‹¤.

  * ë‘ ê°œë¥¼ í•©ì³ í•˜ë‚˜ë¥¼ ë§Œë“œë‹ˆê¹Œ. ê°€ì¥ ë§ˆì§€ë§‰ ì—°ì‚°ì—ì„œ `first`ëŠ” ë½‘í˜€ë„ `second`ëŠ” ëª»ë½‘ì„ ìˆ˜ ìˆë‹¤.



```python
import heapq

def solution(scoville, K):
    answer = 0
    
    heapq.heapify(scoville)
    
    shake = 0
    while True:
        first = heapq.heappop(scoville)
        
        if first >= K:
            return shake
        
        if not scoville:
            return -1
        
        second = heapq.heappop(scoville)
        heapq.heappush(scoville, first + 2*second)
        shake += 1
        
```



## ë””ìŠ¤í¬ ì»¨íŠ¸ë¡¤ëŸ¬

1. ë¹ ë¥¸ ìš”ì²­ë¶€í„° => FIFO
2. ë¹ ë¥¸ ì¢…ë£Œë¶€í„° => ì´ ë¬¸ì œ



##### í—·ê°ˆë ¸ë˜ ì 

* ëë‚˜ëŠ” ì‹œê°„ì„ ë¯¸ë¦¬ ê³„ì‚°í•´ë†“ì„ ìˆ˜ ìˆëŠ”ê°€?

  * NO ! í˜„ì¬ ì‹œê°„ì´ ë‹¬ë¼ì§ì— ë”°ë¼ ìš°ì„ ìˆœìœ„ë„ ë‹¬ë¼ì§ ! í•­ìƒ ìƒˆë¡œ ê³„ì‚° !

  * íŠ¹íˆ ì´ ë¬¸ì œì—ì„œëŠ” "ë””ìŠ¤í¬ê°€ **ì•„ë¬´ ìš”ì²­ë„ ë°›ì§€ ì•Šì•˜ì„ ë•Œ**ì—ëŠ” ë¨¼ì € ë“¤ì–´ì˜¨ ìš”ì²­ë¶€í„° ì²˜ë¦¬"ì¡°ê±´ì´ ìˆìŒ

    ê·¸ëŸ¬ë¯€ë¡œ ìƒˆë¡œ ê³„ì‚°ì‹œì—

    1. ë°›ì„ ìˆ˜ ìˆëŠ” ìš”ì²­ì´ë©´(ì¦‰ `curr_time >= request`) `curr_time + running_time`ì„
    2. ë°›ì„ ìˆ˜ ì—†ëŠ” ìš”ì²­ì´ë©´(`curr_time < request`) => `float('inf')`ë¥¼ ì£¼ì–´ì•¼í•œë‹¤.



```python
import heapq

def solution(jobs):
    answer = 0
    N = len(jobs)

    def get_end_time(curr_time, request, running_time):
        if curr_time < request:
            end_time = float('inf')
        else:
            end_time = curr_time + running_time
        return (end_time, request, running_time)

    curr_time = 0
    jobs = [get_end_time(curr_time, request, running_time) for request, running_time in jobs]

    while jobs:
        heapq.heapify(jobs)
        curr_time, request, running_time = heapq.heappop(jobs)
        
        if curr_time == float('inf'): # í˜„ì¬ ì²˜ë¦¬í•  ìš”ì²­ì´ ì—†ì„ ë•Œ !!!!! => ê°€ì¥ ë¹ ë¥¸ ìš”ì²­ì‹œê°„ìœ¼ë¡œ ê°€ì
            jobs.append((0,request, running_time)) # pop í•´ë²„ë ¸ìœ¼ë‹ˆê¹Œ ë‹¤ì‹œ ë„£ì–´ì£¼ê³ 
            curr_time = min(job[1] for job in jobs) # ìš”ì²­ì„ í•˜ë‚˜ë¼ë„ ë°›ì„ ìˆ˜ ìˆë„ë¡ ê·¸ ì‹œê°„ìœ¼ë¡œ jumpí•˜ì.
        else:
            answer += curr_time - request
            
        jobs = [get_end_time(curr_time, request, running_time) for _, request, running_time in jobs]

    return answer // N
```



## `ëë‚œ ì‹œê°-ìš”ì²­ ì‹œê°` ì˜ meanì´ ì¤„ì–´ë“¤ë„ë¡ ìŠ¤ì¼€ì¤„ì„ ì§œë¼!

#### í˜„ì¬ ì‹œê°„ë§ˆë‹¤ ê°€ì¥ ë¹¨ë¦¬ ëë‚¼ ìˆ˜ ìˆëŠ” taskê°€ ë¬´ì—‡ì¸ì§€ í™•ì¸í•œë‹¤.

![image-20201221001908316](fig/image-20201221001908316.png)

