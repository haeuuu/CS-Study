### ğŸƒâ€â™€ Stack, Queue, Heap, DFS/BFS ë“± ê¸°ë³¸ ë¬¸ì œë¥¼ ë‹¤ì‹œ í’€ì–´ë³´ì !
1. **[Stack/Queue](#Stack/Queue)**
2. **[DFS/BFS](#DFS/BFS)**
2. **[Heap](#Heap)**


---
# Stack/Queue
## ë¯¸ë¡œíƒí—˜
```python
import collections

N,M = map(int,input().split())
A = [list(map(int,input())) for _ in range(N)]

def BFS(x,y):
    q = collections.deque([(x,y)])
    while q:
        x,y = q.popleft()
        for a,b in [(x,y-1),(x,y+1),(x-1,y),(x+1,y)]:
            if 0<=a<N and 0<=b<M and A[a][b] == 1:
                A[a][b] += A[x][y]
                q.append((a,b))
    return A[-1][-1]

print(BFS(0,0))
```

# DFS/BFS

# Heap
## ë” ë§µê²Œ



##### ë°°ì›Œê°ˆ ê²ƒ

* popí•˜ê¸° ì „ì— ì–¸ì œë‚˜ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸ !!!!!!

  íŠ¹íˆ ì´ ë¬¸ì œëŠ” popì„ ë‘ ë²ˆ í•˜ëŠ”ë°, ì²«ë²ˆì§¸ popì´ ì•„ë‹ˆë¼ ë‘ë²ˆì§¸ popì—ì„œ ê±¸ëŸ¬ë‚¸ë‹¤.

  * ë‘ ê°œë¥¼ í•©ì³ í•˜ë‚˜ë¥¼ ë§Œë“œë‹ˆê¹Œ. ê°€ì¥ ë§ˆì§€ë§‰ ì—°ì‚°ì—ì„œ `first`ëŠ” ë½‘í˜€ë„ `second`ëŠ” ëª»ë½‘ì„ ìˆ˜ ìˆë‹¤.



```python
import heapq

def solution(scoville, K):
    answer = 0
    
    heapq.heapify(scoville)
    
    shake = 0
    while True:
        first = heapq.heappop(scoville)
        
        if first >= K:
            return shake
        
        if not scoville:
            return -1
        
        second = heapq.heappop(scoville)
        heapq.heappush(scoville, first + 2*second)
        shake += 1
        
```



## ë””ìŠ¤í¬ ì»¨íŠ¸ë¡¤ëŸ¬

1. ë¹ ë¥¸ ìš”ì²­ë¶€í„° => FIFO
2. ë¹ ë¥¸ ì¢…ë£Œë¶€í„° => ì´ ë¬¸ì œ



##### í—·ê°ˆë ¸ë˜ ì 

* ëë‚˜ëŠ” ì‹œê°„ì„ ë¯¸ë¦¬ ê³„ì‚°í•´ë†“ì„ ìˆ˜ ìˆëŠ”ê°€?

  * NO ! í˜„ì¬ ì‹œê°„ì´ ë‹¬ë¼ì§ì— ë”°ë¼ ìš°ì„ ìˆœìœ„ë„ ë‹¬ë¼ì§ ! í•­ìƒ ìƒˆë¡œ ê³„ì‚° !

  * íŠ¹íˆ ì´ ë¬¸ì œì—ì„œëŠ” "ë””ìŠ¤í¬ê°€ **ì•„ë¬´ ìš”ì²­ë„ ë°›ì§€ ì•Šì•˜ì„ ë•Œ**ì—ëŠ” ë¨¼ì € ë“¤ì–´ì˜¨ ìš”ì²­ë¶€í„° ì²˜ë¦¬"ì¡°ê±´ì´ ìˆìŒ

    ê·¸ëŸ¬ë¯€ë¡œ ìƒˆë¡œ ê³„ì‚°ì‹œì—

    1. ë°›ì„ ìˆ˜ ìˆëŠ” ìš”ì²­ì´ë©´(ì¦‰ `curr_time >= request`) `curr_time + running_time`ì„
    2. ë°›ì„ ìˆ˜ ì—†ëŠ” ìš”ì²­ì´ë©´(`curr_time < request`) => `float('inf')`ë¥¼ ì£¼ì–´ì•¼í•œë‹¤.



```python
import heapq

def solution(jobs):
    answer = 0
    N = len(jobs)

    def get_end_time(curr_time, request, running_time):
        if curr_time < request:
            end_time = float('inf')
        else:
            end_time = curr_time + running_time
        return (end_time, request, running_time)

    curr_time = 0
    jobs = [get_end_time(curr_time, request, running_time) for request, running_time in jobs]

    while jobs:
        heapq.heapify(jobs)
        curr_time, request, running_time = heapq.heappop(jobs)
        
        if curr_time == float('inf'): # í˜„ì¬ ì²˜ë¦¬í•  ìš”ì²­ì´ ì—†ì„ ë•Œ !!!!! => ê°€ì¥ ë¹ ë¥¸ ìš”ì²­ì‹œê°„ìœ¼ë¡œ ê°€ì
            jobs.append((0,request, running_time)) # pop í•´ë²„ë ¸ìœ¼ë‹ˆê¹Œ ë‹¤ì‹œ ë„£ì–´ì£¼ê³ 
            curr_time = min(job[1] for job in jobs) # ìš”ì²­ì„ í•˜ë‚˜ë¼ë„ ë°›ì„ ìˆ˜ ìˆë„ë¡ ê·¸ ì‹œê°„ìœ¼ë¡œ jumpí•˜ì.
        else:
            answer += curr_time - request
            
        jobs = [get_end_time(curr_time, request, running_time) for _, request, running_time in jobs]

    return answer // N
```



## `ëë‚œ ì‹œê°-ìš”ì²­ ì‹œê°` ì˜ meanì´ ì¤„ì–´ë“¤ë„ë¡ ìŠ¤ì¼€ì¤„ì„ ì§œë¼!

#### í˜„ì¬ ì‹œê°„ë§ˆë‹¤ ê°€ì¥ ë¹¨ë¦¬ ëë‚¼ ìˆ˜ ìˆëŠ” taskê°€ ë¬´ì—‡ì¸ì§€ í™•ì¸í•œë‹¤.

![image-20201221001908316](fig/image-20201221001908316.png)

