### 🏃‍♀ Stack, Queue, Heap, DFS/BFS 등 기본 문제를 다시 풀어보자 !
1. **[Stack/Queue](#Stack/Queue)**
2. **[DFS/BFS](#DFS/BFS)**
2. **[Heap](#Heap)**


---
# Stack/Queue
## 미로탐험
```python
import collections

N,M = map(int,input().split())
A = [list(map(int,input())) for _ in range(N)]

def BFS(x,y):
    q = collections.deque([(x,y)])
    while q:
        x,y = q.popleft()
        for a,b in [(x,y-1),(x,y+1),(x-1,y),(x+1,y)]:
            if 0<=a<N and 0<=b<M and A[a][b] == 1:
                A[a][b] += A[x][y]
                q.append((a,b))
    return A[-1][-1]

print(BFS(0,0))
```

# DFS/BFS
## 미로 탐색

최단 거리를 구하는 문제 => BFS !

이 때 지나간 자리는 아예 숫자를 바꿔버리자.

pop이 아니라 append하기 전에 바꾸는 것 잊지말기 !

![image-20201221205122140](../../fig/image-20201221205122140.png)

```python
import collections

N,M = map(int,input().split())
A = [list(map(int,input())) for _ in range(N)]

def BFS(x,y):
    q = collections.deque([(x,y)])
    while q:
        x,y = q.popleft()
        for a,b in [(x,y-1),(x,y+1),(x-1,y),(x+1,y)]:
            if 0<=a<N and 0<=b<M and A[a][b] == 1:
                ###################
                A[a][b] += A[x][y]
                ################### 상태 변화
                q.append((a,b))
    return A[-1][-1]

print(BFS(0,0))
```



## 영역 구하기

직사각형에게 먹히지 않은 종이의 부분부분 중에서 가장 큰 영역의 크기는 얼마?

계산한 칸이라는 의미에서 값을 1로 바꿔준다.

* 역시 init에서 한번, append하기 전에 한 번 상태 변화 !

```python
from collections import deque

M,N,K = map(int, input().split())
paper = [[0]*M for _ in range(N)]

for _ in range(K):
    lx,ly,rx,ry = map(int, input().split())
    for i in range(lx,rx):
        for j in range(ly,ry):
            paper[i][j] = 1

def get_size(x,y):
    size = 0
    queue = deque([(x,y)])
    ###############
    paper[x][y] = 1
    ############### 상태 변화

    while queue:
        x,y = queue.popleft()
        size += 1

        for dx,dy in [(0,1),(1,0),(-1,0),(0,-1)]:
            if x+dx<0 or x+dx>=N or y+dy<0 or y+dy>=M:
                continue
            if paper[x+dx][y+dy] == 0:
                #####################
                paper[x+dx][y+dy] = 1
                ##################### 상태 변화
                queue.append((x+dx,y+dy))

    return size

sizes = []
for i in range(N):
    for j in range(M):
        if paper[i][j] == 0:
            sizes.append(get_size(i,j))

print(len(sizes))
print(*sorted(sizes))
```



## 케빈 베이컨의 6단계 법칙

```python
from collections import deque

N,M = map(int,input().split())
friends = {i:[] for i in range(N)}
for _ in range(M):
    a,b = map(int,input().split())
    friends[a-1].append(b-1)
    friends[b-1].append(a-1)

def get_kevin_number(name):
    queue = deque([(0,name)])
    kevin_num = [-1]*N
    kevin_num[name] = 0

    while queue:
        depth, name = queue.popleft()
        for friend in friends[name]:
            if kevin_num[friend] < 0:
                #############################
                kevin_num[friend] = depth + 1
                #############################
                queue.append((depth + 1, friend))

    return sum(kevin_num)

ans = []
for name in range(N):
    ans.append((get_kevin_number(name),name))
print(sorted(ans)[0][1] + 1)
```



## :speech_balloon: 뿌요뿌요

1. 터뜨릴 블록이 있는지 확인한다.
   * 터뜨릴 수 있다면 좌표를 return하게 한다.
2. 만약 하나도 없다면 중지한다.
3. 하나라도 있다면, 그 좌표를 받아 터뜨린다.
4. 블록을 내린다.

```python
from collections import deque

class Puyo:
    def __init__(self, arr):
        self.arr = arr

    def catch_bomb(self,x,y):
        color = self.arr[x][y]

        self.visit[x][y] = True

        coordinates = []
        queue = deque([(x,y)])

        while queue:
            x,y = queue.popleft()
            coordinates.append((x,y))
            for dx,dy in [(0,1),(1,0),(-1,0),(0,-1)]:
                if x+dx<0 or x+dx>=12 or y+dy<0 or y+dy>=6:
                    continue
                if self.arr[x+dx][y+dy] == color and not self.visit[x+dx][y+dy]:
                    queue.append((x+dx,y+dy))
                    self.visit[x+dx][y+dy] = True

        return coordinates if len(coordinates) >= 4 else []

    def check(self):
        bomb_coordinates = []
        self.visit = [[False]*6 for _ in range(12)]

        for i in range(12):
            for j in range(6):
                if self.arr[i][j] != '.' and not self.visit[i][j]:
                    coord = self.catch_bomb(i,j)
                    if coord:
                        bomb_coordinates.extend(coord)

        return bomb_coordinates

    def pop(self, bomb_coordinates):
        for x,y in bomb_coordinates:
            self.arr[x][y] = '.'

    def drop(self):
        for j in range(6):
            puyo = [self.arr[i][j] for i in range(12) if self.arr[i][j] != '.']
            dropped_puyo = ['.']*(12-len(puyo)) + puyo
            for i in range(12):
                self.arr[i][j] = dropped_puyo[i]

puyo = Puyo([list(input()) for _ in range(12)])

answer = 0
while True:
    bomb_coordinates = puyo.check()
    if not bomb_coordinates:
        break
    puyo.pop(bomb_coordinates)
    puyo.drop()
    answer += 1

print(answer)
```



## :speech_balloon: ​ 로봇

> 구구절절 하지만 디버깅하기 편하다 !

```python
from collections import deque

class Robot:
    def __init__(self, n,m,arr, init, goal):
        self.arr = arr
        self.n,self.m = n,m
        self.init_x, self.init_y, self.init_dir = init
        self.goal_x, self.goal_y, self.goal_dir = goal
        self.turn_left = {1:4,4:2,2:3,3:1}
        self.turn_right = {1:3,3:2,2:4,4:1}

    def end_state(self,x,y,dir):
        return (x,y,dir) == (self.goal_x, self.goal_y, self.goal_dir)

    def go(self,x,y,dir,k):

        if dir == 1 or dir == 2:
            view = range(y,y+k+1) if dir == 1 else range(y-k,y)
            for j in view:
                if j < 0 or j >= self.m or self.arr[x][j] == 1:
                    return False, (x,y,dir)
            return True, (x,view[-1 if dir == 1 else 0],dir)
        else:
            view = range(x,x+k+1) if dir == 3 else range(x-k,x)
            for i in view:
                if i < 0 or i >= self.n or self.arr[i][y] == 1:
                    return False, (x,y,dir)
            return True, (view[-1 if dir == 3 else 0],y,dir)

    def turn(self,x,y,dir,where):
        if where == 0: # 왼쪽
            return x,y,self.turn_left[dir]
        else:
            return x,y,self.turn_right[dir]

    def move(self):
        visit = [[[False]*5 for _ in range(m)] for _ in range(n)]
        queue = deque([(self.init_x,self.init_y,self.init_dir,0)])
        visit[self.init_x][self.init_y][self.init_dir] = True

        while queue:
            x,y,dir,depth = queue.popleft()
            if self.end_state(x,y,dir):
                return depth

            for rotate in [0,1]:
                nx,ny,ndir = self.turn(x,y,dir, rotate)
                if not visit[nx][ny][ndir]:
                    visit[nx][ny][ndir] = True
                    queue.append((nx,ny,ndir,depth+1))

            for k in [1,2,3]:
                flag,(nx,ny,ndir) = self.go(x,y,dir,k)
                if flag and not visit[nx][ny][ndir]:
                    visit[nx][ny][ndir] = True
                    queue.append((nx,ny,ndir,depth+1))

import sys
f = lambda :list(map(int,sys.stdin.readline().strip().split()))

n,m = f()
arr = [f() for _ in range(n)]

sx,sy,sdir = f()
ex,ey,edir = f()
robot = Robot(n,m,arr,(sx-1,sy-1,sdir),(ex-1,ey-1,edir))
print(robot.move())
```



## 안전영역

```python
import sys
sys.setrecursionlimit(2**30)

N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]

M = max(max(ls) for ls in arr)

def raining(k):
    for i in range(N):
        for j in range(N):
            if arr[i][j] <= k:
                arr[i][j] *= -1

def sunny():
    for i in range(N):
        for j in range(N):
            arr[i][j] *= -1

def DFS(x, y):
    arr[x][y] *= -1
    for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
        if x + dx < 0 or x + dx >= N or y + dy < 0 or y + dy >= N:
            continue
        if arr[x + dx][y + dy] > 0:
            DFS(x + dx, y + dy)

answers = []
for k in range(M + 1):
    raining(k)
    safty = 0
    for i in range(N):
        for j in range(N):
            if arr[i][j] > 0:
                DFS(i, j)
                safty += 1
    answers.append(safty)
    sunny()
print(max(answers))
```



# Heap
## 더 맵게



##### 배워갈 것

* pop하기 전에 언제나 비어있는지 확인 !!!!!!

  특히 이 문제는 pop을 두 번 하는데, 첫번째 pop이 아니라 두번째 pop에서 걸러낸다.

  * 두 개를 합쳐 하나를 만드니까. 가장 마지막 연산에서 `first`는 뽑혀도 `second`는 못뽑을 수 있다.



```python
import heapq

def solution(scoville, K):
    answer = 0
    
    heapq.heapify(scoville)
    
    shake = 0
    while True:
        first = heapq.heappop(scoville)
        
        if first >= K:
            return shake
        
        if not scoville:
            return -1
        
        second = heapq.heappop(scoville)
        heapq.heappush(scoville, first + 2*second)
        shake += 1
        
```



## 디스크 컨트롤러

1. 빠른 요청부터 => FIFO
2. 빠른 종료부터 => 이 문제



##### 헷갈렸던 점

* 끝나는 시간을 미리 계산해놓을 수 있는가?

  * NO ! 현재 시간이 달라짐에 따라 우선순위도 달라짐 ! 항상 새로 계산 !

  * 특히 이 문제에서는 "디스크가 **아무 요청도 받지 않았을 때**에는 먼저 들어온 요청부터 처리"조건이 있음

    그러므로 새로 계산시에

    1. 받을 수 있는 요청이면(즉 `curr_time >= request`) `curr_time + running_time`을
    2. 받을 수 없는 요청이면(`curr_time < request`) => `float('inf')`를 주어야한다.



```python
import heapq

def solution(jobs):
    answer = 0
    N = len(jobs)

    def get_end_time(curr_time, request, running_time):
        if curr_time < request:
            end_time = float('inf')
        else:
            end_time = curr_time + running_time
        return (end_time, request, running_time)

    curr_time = 0
    jobs = [get_end_time(curr_time, request, running_time) for request, running_time in jobs]

    while jobs:
        heapq.heapify(jobs)
        curr_time, request, running_time = heapq.heappop(jobs)
        
        if curr_time == float('inf'): # 현재 처리할 요청이 없을 때 !!!!! => 가장 빠른 요청시간으로 가자
            jobs.append((0,request, running_time)) # pop 해버렸으니까 다시 넣어주고
            curr_time = min(job[1] for job in jobs) # 요청을 하나라도 받을 수 있도록 그 시간으로 jump하자.
        else:
            answer += curr_time - request
            
        jobs = [get_end_time(curr_time, request, running_time) for _, request, running_time in jobs]

    return answer // N
```



## `끝난 시각-요청 시각` 의 mean이 줄어들도록 스케줄을 짜라!

#### 현재 시간마다 가장 빨리 끝낼 수 있는 task가 무엇인지 확인한다.

![image-20201221001908316](fig/image-20201221001908316.png)

