### 🏃‍♀ Stack, Queue, Heap, DFS/BFS 등 기본 문제를 다시 풀어보자 !
1. **[Stack/Queue](#Stack/Queue)**
2. **[DFS/BFS](#DFS/BFS)**
2. **[Heap](#Heap)**


---
# Stack/Queue
## 미로탐험
```python
import collections

N,M = map(int,input().split())
A = [list(map(int,input())) for _ in range(N)]

def BFS(x,y):
    q = collections.deque([(x,y)])
    while q:
        x,y = q.popleft()
        for a,b in [(x,y-1),(x,y+1),(x-1,y),(x+1,y)]:
            if 0<=a<N and 0<=b<M and A[a][b] == 1:
                A[a][b] += A[x][y]
                q.append((a,b))
    return A[-1][-1]

print(BFS(0,0))
```

# DFS/BFS

# Heap
## 더 맵게



##### 배워갈 것

* pop하기 전에 언제나 비어있는지 확인 !!!!!!

  특히 이 문제는 pop을 두 번 하는데, 첫번째 pop이 아니라 두번째 pop에서 걸러낸다.

  * 두 개를 합쳐 하나를 만드니까. 가장 마지막 연산에서 `first`는 뽑혀도 `second`는 못뽑을 수 있다.



```python
import heapq

def solution(scoville, K):
    answer = 0
    
    heapq.heapify(scoville)
    
    shake = 0
    while True:
        first = heapq.heappop(scoville)
        
        if first >= K:
            return shake
        
        if not scoville:
            return -1
        
        second = heapq.heappop(scoville)
        heapq.heappush(scoville, first + 2*second)
        shake += 1
        
```



## 디스크 컨트롤러

1. 빠른 요청부터 => FIFO
2. 빠른 종료부터 => 이 문제



##### 헷갈렸던 점

* 끝나는 시간을 미리 계산해놓을 수 있는가?

  * NO ! 현재 시간이 달라짐에 따라 우선순위도 달라짐 ! 항상 새로 계산 !

  * 특히 이 문제에서는 "디스크가 **아무 요청도 받지 않았을 때**에는 먼저 들어온 요청부터 처리"조건이 있음

    그러므로 새로 계산시에

    1. 받을 수 있는 요청이면(즉 `curr_time >= request`) `curr_time + running_time`을
    2. 받을 수 없는 요청이면(`curr_time < request`) => `float('inf')`를 주어야한다.



```python
import heapq

def solution(jobs):
    answer = 0
    N = len(jobs)

    def get_end_time(curr_time, request, running_time):
        if curr_time < request:
            end_time = float('inf')
        else:
            end_time = curr_time + running_time
        return (end_time, request, running_time)

    curr_time = 0
    jobs = [get_end_time(curr_time, request, running_time) for request, running_time in jobs]

    while jobs:
        heapq.heapify(jobs)
        curr_time, request, running_time = heapq.heappop(jobs)
        
        if curr_time == float('inf'): # 현재 처리할 요청이 없을 때 !!!!! => 가장 빠른 요청시간으로 가자
            jobs.append((0,request, running_time)) # pop 해버렸으니까 다시 넣어주고
            curr_time = min(job[1] for job in jobs) # 요청을 하나라도 받을 수 있도록 그 시간으로 jump하자.
        else:
            answer += curr_time - request
            
        jobs = [get_end_time(curr_time, request, running_time) for _, request, running_time in jobs]

    return answer // N
```



## `끝난 시각-요청 시각` 의 mean이 줄어들도록 스케줄을 짜라!

#### 현재 시간마다 가장 빨리 끝낼 수 있는 task가 무엇인지 확인한다.

![image-20201221001908316](fig/image-20201221001908316.png)

