> [설명](https://www.crocus.co.kr/733)
>
> [python code](https://www.fun-coding.org/Chapter20-prim-live.html)



# :christmas_tree: Prim Algorithm



## :fire: Kruskal v.s. Prim

`Kruskal` : **전체**를 보며, 일단 이어지지 않더라도 간선을 골라나간다.

`Prim` : **내가 밟은 node 주변만 보며**, 이어질 수 있도록 골라나간다.



### 1 ) 공통점 : Greedy하다.

당장 선택할 수 있는 것 중에서 가장 cost가 낮은 간선을 선택하고 이를 통해 전체의 최적 솔루션을 찾는다.



### 2 ) 차이점 : edge의 선택이 독립적?종속적?

* ###### 크루스칼은 이전 선택에 독립적이다. 어떤 간선이라도 선택할 수 있다.

  이전 그래프와 **연결되어있지 않아도 선택 가능.**

  edge를 선택하는 과정은, 단지 오름차순. 즉 순서는 무시되고

  무조건 작은 것부터 고름 !

* ###### Prim 알고리즘은 이전의 선택에 종속된다.

  이전 그래프와 **이어져있는 edge만** 선택할 수 있음.

  지금 선택할 수 있는 edge는 이전 그래프에 따라 달라진다,



### 3 ) Time Complexity

간선의 갯수가 적은 경우엔 크루스칼을, 많은 경우에는 프림 알고리즘이 낫다.



## Algorithm

> 잘 생각해보면 **다익스트라를 약~간 변형하면 된다**는 것을 알 수 있다 !
>
> * 고려되는 edge의 한 쪽 끝은 이미 탐색이 끝난 상태임.
> * 만약 선택하려는 edge의 나머지 끝 역시 이미 탐색된 node라면, cycle이 생김.
>   즉 union-find를 사용하지 않아도 Explored를 통해 cycle을 파악할 수 있다.



```python
N,M = 7,11 # node, edge 수
arr = [(1,7,12),(1,4,28),(1,2,67),(2,4,24),
       (2,5,62),(3,5,20),(3,6,37),(4,7,13),
       (5,6,45),(5,7,73),(1,5,17)]

A = [[] for _ in range(N+1)]
for a,b,cost in arr:
    A[a].append([cost,a,b])
    A[b].append([cost,b,a])

print(A)
```

```python
from heapq import *

start = 1
Frontier = A[start]
heapify(Frontier) # 요거 안해가지고 틀릴뻔 ㅎㅎ
Explored = [False]*(N+1)
Explored[start] = True

minimum_cost = 0
selected_edge = 0

########################## N-1개의 간선만 선택하면 끝난다 !
while selected_edge < N-1:
########################## 중간에 continue가 있으므로 for loop보단 while쓰자
    cost,s,e = heappop(Frontier)

    if Explored[e]: # s는 이미 Explored한 점임 !
        continue
    Explored[e] = True
    
    print(f'{s}=>{e}, {cost}원')
    
    minimum_cost += cost
    selected_edge += 1

    print(A[e])
    for cost,s,e in A[e]:
        heappush(Frontier, [cost,s,e])

print("최소 비용은 :",minimum_cost)
```



## 1197 최소스패닝트리

위 코드를 그대로 이용해서 푼 결과.

![image-20200922114010921](../fig/image-20200922114010921.png)

5달 전에 크루스칼으로 풀었었는데 시간, 메모리면에서 크루스칼이 나은 것을 볼 수 있다.

아마도 다음 조건처럼 간선의 갯수 E가 V^2^ 까지 들어오지 않기 때문에 일어난 현상으로 보인다 !

> 첫째 줄에 정점의 개수 V(1 ≤ V ≤ **10,000**)와 간선의 개수 E(1 ≤ E ≤ **100,000**)가 주어진다.



```python
# map

[[], [[12, 1, 7], [28, 1, 4], [67, 1, 2], [17, 1, 5]], [[67, 2, 1], [24, 2, 4], [62, 2, 5]], [[20, 3, 5], [37, 3, 6]], [[28, 4, 1], [24, 4, 2], [13, 4, 7]], [[62, 5, 2], [20, 5, 3], [45, 5, 6], [73, 5, 7], [17, 5, 1]], [[37, 6, 3], [45, 6, 5]], [[12, 7, 1], [13, 7, 4], [73, 7, 5]]]

# edge 선택 결과

1=>7, 12원
[[12, 7, 1], [13, 7, 4], [73, 7, 5]]

7=>4, 13원
[[28, 4, 1], [24, 4, 2], [13, 4, 7]]

1=>5, 17원
[[62, 5, 2], [20, 5, 3], [45, 5, 6], [73, 5, 7], [17, 5, 1]]

5=>3, 20원
[[20, 3, 5], [37, 3, 6]]

4=>2, 24원
[[67, 2, 1], [24, 2, 4], [62, 2, 5]]

3=>6, 37원
[[37, 6, 3], [45, 6, 5]]

최소 비용은 : 123
```

